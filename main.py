import json
from openai import OpenAI
from pandas import read_csv
from docx import Document
from docx.shared import Pt
import os
from tenacity import retry, wait_chain, wait_fixed
from time import sleep

class TextCreator:
    def __init__(   
                    self, 
                    api_key: str,
                    keyword: str,
                    country: str,
                    prompts: list,
                    result_folder_path: str,
                    gpt_version: str,
                    sync_data: bool
                ):
        self.prompts = prompts
        self.api_key = api_key
        self.keyword = keyword
        self.country = country
        self.result_folder_path = result_folder_path
        self.gpt_version = gpt_version
        self.sync_data = sync_data


    def create_full_text(self) -> None:
        """
        Generates full .docx document from different parts
        """
        self.prestart()
        document = Document()
        text_result = []
        for prompt in self.prompts:
            document, text = self.generate_text_from_prompt(document, prompt)
            text_result.append(text)
            if self.gpt_version == "GPT-3.5":
                sleep(30)
        document.save(os.path.join(self.result_folder_path, f"{self.keyword.replace(' ', '_').lower()}_{self.country.replace(' ', '_').lower()}", f"{self.keyword.replace(' ', '_').lower()}_{self.country.replace(' ', '_').lower()}.docx"))
        if self.sync_data:
            self.syncronize_texts(text_result)

    def prestart(self):
        os.makedirs(os.path.join(self.result_folder_path, f"{self.keyword.replace(' ', '_').lower()}_{self.country.replace(' ', '_').lower()}"), exist_ok=True)

    @retry(wait=wait_chain(*[wait_fixed(10) for i in range(6)]))
    def generate_text_from_prompt(self, document: Document, prompt):
        query = f"""Generate text according to the next rules:\n1. Change [keyword]='{self.keyword}' and [country]='{self.country}' in the text.\n 2. If [country]="nan" then generate text without this parameter.\n"""
        query += """3. If you need to generate a table, do not use "|" symbols for visual display of table. Use only '\t' and '\n' symbols for table displayment. Table must be maximum in 2 columns, so write each key:value pairs in new row.\n4. In case if I ask you to make FAQ section, then firstly write question, then ":" and after that answer for this question and create as numeric list.\n5. If I do not ask you make FAQ section, then do not do it.\n6. At the end of your response add '\n\n \n Rules are finished, now you have to generate data according to rules: \n"""
        query += prompt
        generated_data = self.get_message_from_chat(query)
        if not generated_data or "Sorry" in generated_data or 'sorry' in generated_data or 'apologize' in generated_data:
            raise
        # data = json.loads(generated_data.replace('`', '').replace('json', ''))
        document.add_paragraph(generated_data)
        print(generated_data)
        return document, generated_data
    
    @retry(wait=wait_chain(*[wait_fixed(10) for i in range(6)]))
    def syncronize_texts(self, texts):
        resulted_text = '\n'.join(texts)
        query = f"""Check the text below. Remove duplicated information but leave absolutely the same content structure with all paragraphs, tables and lists. Rewrite data to synchronize all data through the text.\n"""
        query += resulted_text
        res = self.get_message_from_chat(query)
        if not res:
            raise
        document = Document()
        document.add_paragraph(res)
        document.save(os.path.join(self.result_folder_path, f"{self.keyword.replace(' ', '_').lower()}_{self.country.replace(' ', '_').lower()}", f"{self.keyword.replace(' ', '_').lower()}_{self.country.replace(' ', '_').lower()}(1).docx"))
        # return resulted_text

    def get_message_from_chat(self, question: str) -> str:
        """
        Returns generated by chatgpt response as text.
        """
        # try:
        client = OpenAI(api_key=self.api_key)
        models = {
            "GPT-4": "gpt-4", 
            "GPT-4 Turbo": "gpt-4-1106-preview", 
            "GPT-3.5": "gpt-3.5-turbo-1106"
        }
        try:
            response = client.chat.completions.create(
                model=models[self.gpt_version],
                messages=[
                    {
                    "role": "user",
                    "content": question
                    }
                ],
                temperature=1,
                max_tokens=4096,
                top_p=1,
                frequency_penalty=0,
                presence_penalty=0
            )
        except Exception as ex:
            print(ex)
            raise
        result = response.choices[0].message.content
        return result