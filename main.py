import json
from openai import OpenAI
from pandas import read_csv
from docx import Document
from docx.shared import Pt
import os
from tenacity import retry, wait_chain, wait_fixed

class TextCreator:
    def __init__(   
                    self, 
                    api_key: str,
                    keyword: str,
                    country: str,
                    prompts: list,
                    result_folder_path: str,
                    gpt_version: str,
                    sync_data: bool
                ):
        self.prompts = prompts
        self.api_key = api_key
        self.keyword = keyword
        self.country = country
        self.result_folder_path = result_folder_path
        self.gpt_version = gpt_version
        self.sync_data = sync_data


    def create_full_text(self) -> None:
        """
        Generates full .docx document from different parts
        """
        self.prestart()
        document = Document()
        text_result = []
        for prompt in self.prompts:
            document, text = self.generate_text_from_prompt(document, prompt)
            text_result.append(text)
        document.save(os.path.join(self.result_folder_path, f"{self.keyword.replace(' ', '_').lower()}_{self.country.replace(' ', '_').lower()}", f"{self.keyword.replace(' ', '_').lower()}_{self.country.replace(' ', '_').lower()}.docx"))
        if self.sync_data:
            self.syncronize_texts(text_result)

    def prestart(self):
        os.makedirs(os.path.join(self.result_folder_path, f"{self.keyword.replace(' ', '_').lower()}_{self.country.replace(' ', '_').lower()}"), exist_ok=True)

    def generate_text_from_prompt(self, document: Document, prompt):
        query = f""" Generate data where [keyword]={self.keyword} and [country]={self.country}:\n"""
        query += prompt
        query += """\n Generate as text. Only if you need to generate a table, do not use "|" symblols for visual display, use only tabulation and new line symbols, every pair in list start from new line, make different tabulations to display values in pretty way, like in columns. 
                    Only if requst asks to make FAQ block, then firstly write question, then ":" and after that answer for this question and create as numeric list. At the end add "\n\n" """
        generated_data = self.get_message_from_chat(query)
        # data = json.loads(generated_data.replace('`', '').replace('json', ''))
        document.add_paragraph(generated_data)
        print(generated_data)
        return document, generated_data
    
    def syncronize_texts(self, texts):
        resulted_text = '\n'.join(texts)
        query = f"""Check the text below. Remove duplicated information but leave fully the same content structure. Rewrite data to synchronize all data through the text.\n"""
        query += resulted_text
        res = self.get_message_from_chat(query)
        document = Document()
        document.add_paragraph(res)
        document.save(os.path.join(self.result_folder_path, f"{self.keyword.replace(' ', '_').lower()}_{self.country.replace(' ', '_').lower()}", f"{self.keyword.replace(' ', '_').lower()}_{self.country.replace(' ', '_').lower()}(1).docx"))
        # return resulted_text

    def get_message_from_chat(self, question: str) -> str:
        """
        Returns generated by chatgpt response as text.
        """
        # try:
        client = OpenAI(api_key=self.api_key)
        models = {
            "GPT-4": "gpt-4", 
            "GPT-4 Turbo": "gpt-4-1106-preview", 
            "GPT-3.5": "gpt-3.5-turbo-1106"
        }
        try:
            response = client.chat.completions.create(
                model=models[self.gpt_version],
                messages=[
                    {
                    "role": "user",
                    "content": question
                    }
                ],
                temperature=1,
                max_tokens=4096,
                top_p=1,
                frequency_penalty=0,
                presence_penalty=0
            )
        except Exception as ex:
            print(ex)
            raise
        result = response.choices[0].message.content
        return result